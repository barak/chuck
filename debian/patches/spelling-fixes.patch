From: "Barak A. Pearlmutter" <bap@debian.org>
Date: Thu, 19 May 2022 11:30:00 +0000
Subject: Fix typos

---
 src/core/chuck_lang.cpp  | 18 +++++++++---------
 src/core/chuck_type.cpp  |  4 ++--
 src/core/chuck_vm.cpp    |  2 +-
 src/core/uana_xform.cpp  |  8 ++++----
 src/core/ugen_stk.cpp    |  4 ++--
 src/core/ugen_stk.h      |  2 +-
 src/core/ulib_math.cpp   |  2 +-
 src/host/chuck_audio.cpp |  2 +-
 8 files changed, 21 insertions(+), 21 deletions(-)

diff --git a/src/core/chuck_lang.cpp b/src/core/chuck_lang.cpp
index 56855f6..c94f56b 100644
--- a/src/core/chuck_lang.cpp
+++ b/src/core/chuck_lang.cpp
@@ -802,53 +802,53 @@ t_CKBOOL init_class_string( Chuck_Env * env, Chuck_Type * type )
     // add find()
     func = make_new_mfun( "int", "find", string_find );
     func->add_arg( "int", "theChar" );
-    func->doc = "get the index of the first occurence of theChar, or -1 if theChar is not found.";
+    func->doc = "get the index of the first occurrence of theChar, or -1 if theChar is not found.";
     if( !type_engine_import_mfun( env, func ) ) goto error;
     
     // add find()
     func = make_new_mfun( "int", "find", string_findStart );
     func->add_arg( "int", "theChar" );
     func->add_arg( "int", "start" );
-    func->doc = "get the index of the first occurence of theChar at or after the start position, or -1 if theChar is not found.";
+    func->doc = "get the index of the first occurrence of theChar at or after the start position, or -1 if theChar is not found.";
     if( !type_engine_import_mfun( env, func ) ) goto error;
     
     // add find()
     func = make_new_mfun( "int", "find", string_findStr );
     func->add_arg( "string", "str" );
-    func->doc = "get the index of the first occurence of str, or -1 if str is not found.";
+    func->doc = "get the index of the first occurrence of str, or -1 if str is not found.";
     if( !type_engine_import_mfun( env, func ) ) goto error;
     
     // add find()
     func = make_new_mfun( "int", "find", string_findStrStart );
     func->add_arg( "string", "str" );
     func->add_arg( "int", "start" );
-    func->doc = "get the index of the first occurence of str at or after the start position, or -1 if str is not found.";
+    func->doc = "get the index of the first occurrence of str at or after the start position, or -1 if str is not found.";
     if( !type_engine_import_mfun( env, func ) ) goto error;
     
     // add rfind()
     func = make_new_mfun( "int", "rfind", string_rfind );
     func->add_arg( "int", "theChar" );
-    func->doc = "get the index of the last occurence of theChar, or -1 if theChar is not found.";
+    func->doc = "get the index of the last occurrence of theChar, or -1 if theChar is not found.";
     if( !type_engine_import_mfun( env, func ) ) goto error;
     
     // add rfind()
     func = make_new_mfun( "int", "rfind", string_rfindStart );
     func->add_arg( "int", "theChar" );
     func->add_arg( "int", "start" );
-    func->doc = "get the index of the last occurence of theChar at or before the start position, or -1 if theChar is not found.";
+    func->doc = "get the index of the last occurrence of theChar at or before the start position, or -1 if theChar is not found.";
     if( !type_engine_import_mfun( env, func ) ) goto error;
     
     // add rfind()
     func = make_new_mfun( "int", "rfind", string_rfindStr );
     func->add_arg( "string", "str" );
-    func->doc = "get the index of the last occurence of str, or -1 if str is not found.";
+    func->doc = "get the index of the last occurrence of str, or -1 if str is not found.";
     if( !type_engine_import_mfun( env, func ) ) goto error;
     
     // add rfind()
     func = make_new_mfun( "int", "rfind", string_rfindStrStart );
     func->add_arg( "string", "str" );
     func->add_arg( "int", "start" );
-    func->doc = "get the index of the last occurence of str at or before the start position, or -1 if str is not found.";
+    func->doc = "get the index of the last occurrence of str at or before the start position, or -1 if str is not found.";
     if( !type_engine_import_mfun( env, func ) ) goto error;
     
     // add erase()
@@ -860,7 +860,7 @@ t_CKBOOL init_class_string( Chuck_Env * env, Chuck_Type * type )
 
     // add toInt()
     func = make_new_mfun( "int", "toInt", string_toInt );
-    func->doc = "attemp to convert the contents of the string to an integer and return the result, or 0 if conversion failed.";
+    func->doc = "attempt to convert the contents of the string to an integer and return the result, or 0 if conversion failed.";
     if( !type_engine_import_mfun( env, func ) ) goto error;
 
     // add toFloat()
diff --git a/src/core/chuck_type.cpp b/src/core/chuck_type.cpp
index 711f877..e044368 100644
--- a/src/core/chuck_type.cpp
+++ b/src/core/chuck_type.cpp
@@ -3845,7 +3845,7 @@ t_CKBOOL type_engine_check_class_def( Chuck_Env * env, a_Class_Def class_def )
                     "cannot extend incomplete type '%s'",
                     t_parent->c_name() );
                 EM_error2( class_def->ext->linepos,
-                    "...(note: the parent's declaration must preceed child's)" );
+                    "...(note: the parent's declaration must precede child's)" );
                 return FALSE;
             }
         }
@@ -6486,7 +6486,7 @@ t_CKBOOL escape_str( char * str_lit, int linepos )
             // make sure next char
             if( *str_lit == '\0' )
             {
-                EM_error2( linepos, "invalid: string ends with escape charactor '\\'" );
+                EM_error2( linepos, "invalid: string ends with escape character '\\'" );
                 return FALSE;
             }
             
diff --git a/src/core/chuck_vm.cpp b/src/core/chuck_vm.cpp
index ad0247d..dee9791 100644
--- a/src/core/chuck_vm.cpp
+++ b/src/core/chuck_vm.cpp
@@ -935,7 +935,7 @@ t_CKUINT Chuck_VM::process_msg( Chuck_Msg * msg )
     {
         t_CKUINT n = m_shreduler->highest();
         m_shred_id = n;
-        CK_FPRINTF_STDERR( "[chuck](VM): reseting shred id to %lu...\n", m_shred_id + 1 );
+        CK_FPRINTF_STDERR( "[chuck](VM): resetting shred id to %lu...\n", m_shred_id + 1 );
     }
 
 done:
diff --git a/src/core/uana_xform.cpp b/src/core/uana_xform.cpp
index 1a24a3a..8d76058 100644
--- a/src/core/uana_xform.cpp
+++ b/src/core/uana_xform.cpp
@@ -171,7 +171,7 @@ DLL_QUERY xform_query( Chuck_DL_Query * QUERY )
     // init as base class: FFT
     //---------------------------------------------------------------------
 
-    doc = "computes the Fast Fourier Transform on incoming audio samples, and outputs the result via its UAnaBlob as both the complex spectrum and the magnitude spectrum. A buffering mechanism maintains the previous FFTsize # of samples, allowing FFT's to be taken at any point in time, on demand (via .upchuck() or by upchucking a downstream UAna. The window size (along with an arbitry window shape) is controlled via the .window method. The hop size is complete dynamic, and is throttled by how time is advanced.";
+    doc = "computes the Fast Fourier Transform on incoming audio samples, and outputs the result via its UAnaBlob as both the complex spectrum and the magnitude spectrum. A buffering mechanism maintains the previous FFTsize # of samples, allowing FFT's to be taken at any point in time, on demand (via .upchuck() or by upchucking a downstream UAna. The window size (along with an arbitrary window shape) is controlled via the .window method. The hop size is complete dynamic, and is throttled by how time is advanced.";
     
     if( !type_engine_import_uana_begin( env, "FFT", "UAna", env->global(),
                                         FFT_ctor, FFT_dtor,
@@ -224,7 +224,7 @@ DLL_QUERY xform_query( Chuck_DL_Query * QUERY )
     // init as base class: IFFT
     //---------------------------------------------------------------------
     
-    doc = "computes the inverse Fast Fourier Transform on incoming spectral frames (on demand), and overlap-adds the results into its internal buffer, ready to be sent to other UGen's connected via =>. The window size (along with an arbitry window shape) is controlled via the .window method.";
+    doc = "computes the inverse Fast Fourier Transform on incoming spectral frames (on demand), and overlap-adds the results into its internal buffer, ready to be sent to other UGen's connected via =>. The window size (along with an arbitrary window shape) is controlled via the .window method.";
     
     if( !type_engine_import_uana_begin( env, "IFFT", "UAna", env->global(), 
                                         IFFT_ctor, IFFT_dtor,
@@ -420,7 +420,7 @@ DLL_QUERY xform_query( Chuck_DL_Query * QUERY )
     // init as base class: DCT
     //---------------------------------------------------------------------
     
-    doc = "computes the Discrete Cosine Transform on incoming audio samples, and outputs the result via its UAnaBlob as real values in the D.C. spectrum. A buffering mechanism maintains the previous DCT size # of samples, allowing DCT to be taken at any point in time, on demand (via .upchuck() or by upchucking a downstream UAna; see UAna documentation). The window size (along with an arbitry window shape) is controlled via the .window method. The hop size is complete dynamic, and is throttled by how time is advanced.";
+    doc = "computes the Discrete Cosine Transform on incoming audio samples, and outputs the result via its UAnaBlob as real values in the D.C. spectrum. A buffering mechanism maintains the previous DCT size # of samples, allowing DCT to be taken at any point in time, on demand (via .upchuck() or by upchucking a downstream UAna; see UAna documentation). The window size (along with an arbitrary window shape) is controlled via the .window method. The hop size is complete dynamic, and is throttled by how time is advanced.";
     
     if( !type_engine_import_uana_begin( env, "DCT", "UAna", env->global(), 
                                         DCT_ctor, DCT_dtor,
@@ -473,7 +473,7 @@ DLL_QUERY xform_query( Chuck_DL_Query * QUERY )
     // init as base class: IDCT
     //---------------------------------------------------------------------
     
-    doc = "computes the inverse Discrete Cosine Transform on incoming spectral frames (on demand), and overlap-adds the results into its internal buffer, ready to be sent to other UGen's connected via =>. The window size (along with an arbitry window shape) is controlled via the .window method.";
+    doc = "computes the inverse Discrete Cosine Transform on incoming spectral frames (on demand), and overlap-adds the results into its internal buffer, ready to be sent to other UGen's connected via =>. The window size (along with an arbitrary window shape) is controlled via the .window method.";
     
     if( !type_engine_import_uana_begin( env, "IDCT", "UAna", env->global(), 
                                         IDCT_ctor, IDCT_dtor,
diff --git a/src/core/ugen_stk.cpp b/src/core/ugen_stk.cpp
index 2815722..f7075df 100644
--- a/src/core/ugen_stk.cpp
+++ b/src/core/ugen_stk.cpp
@@ -2755,11 +2755,11 @@ by Perry R. Cook and Gary P. Scavone, 1995 - 2002.";
 
     func = make_new_mfun( "float", "stretch", StifKarp_ctrl_stretch ); 
     func->add_arg( "float", "value" );
-    func->doc = "set string strech, [0.0-1.0].";
+    func->doc = "set string stretch, [0.0-1.0].";
     if( !type_engine_import_mfun( env, func ) ) goto error;
 
     func = make_new_mfun( "float", "stretch", StifKarp_cget_stretch );
-    func->doc = "get string strech, [0.0-1.0].";
+    func->doc = "get string stretch, [0.0-1.0].";
     if( !type_engine_import_mfun( env, func ) ) goto error;
 
     func = make_new_mfun( "float", "sustain", StifKarp_ctrl_sustain ); 
diff --git a/src/core/ugen_stk.h b/src/core/ugen_stk.h
index 138d8e1..79c89dc 100644
--- a/src/core/ugen_stk.h
+++ b/src/core/ugen_stk.h
@@ -5195,7 +5195,7 @@ class Sitar : public Instrmnt
     The user is responsible for checking the values
     returned by the read/write methods.  Values
     less than or equal to zero indicate a closed
-    or lost connection or the occurence of an error.
+    or lost connection or the occurrence of an error.
 
     by Perry R. Cook and Gary P. Scavone, 1995 - 2002.
 */
diff --git a/src/core/ulib_math.cpp b/src/core/ulib_math.cpp
index 5ccb392..77d00f9 100644
--- a/src/core/ulib_math.cpp
+++ b/src/core/ulib_math.cpp
@@ -365,7 +365,7 @@ DLL_QUERY libmath_query( Chuck_DL_Query * QUERY )
     // add srandom (1.3.1.0)
     QUERY->add_sfun( QUERY, srandom_impl, "void", "srandom" );
     QUERY->add_arg( QUERY, "int", "seed" );
-    QUERY->doc_func( QUERY, "seed the random nubmer generator." );
+    QUERY->doc_func( QUERY, "seed the random number generator." );
     
     // go ahead and seed (the code can seed again for repeatability; 1.3.1.0)
     srandom( time( NULL ) );
diff --git a/src/host/chuck_audio.cpp b/src/host/chuck_audio.cpp
index 8de7d1d..c79e538 100644
--- a/src/host/chuck_audio.cpp
+++ b/src/host/chuck_audio.cpp
@@ -328,7 +328,7 @@ static unsigned int __stdcall watch_dog( void * )
     t_CKUINT priority = XThreadUtil::our_priority;
 
     // log
-    EM_log( CK_LOG_SEVERE, "starting real-time watch dog processs..." );
+    EM_log( CK_LOG_SEVERE, "starting real-time watch dog process..." );
     // push log
     EM_pushlog();
     EM_log( CK_LOG_INFO, "watchdog timeout: %f::second", g_watchdog_timeout );
